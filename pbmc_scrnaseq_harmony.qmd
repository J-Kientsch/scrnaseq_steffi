
---
title: "scRNASeq_Steffi_PBMCs — fixed modern workflow (Seurat v5, SCT v2, Harmony, SingleR, pseudobulk DE)"
author: "Jacky K"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
editor: source

execute:
  echo: true
  warning: true
  message: true
---

## 0) Environment

```{r}
rm(list = ls())
set.seed(156)
if (!requireNamespace("future", quietly = TRUE)) install.packages("future")
future::plan("sequential")
options(future.globals.maxSize = 110 * 1024^3)
```

## 1) Packages

```{r}
if (!requireNamespace("pacman", quietly = TRUE)) install.packages("pacman")
library(pacman)

pacman::p_load(
  Seurat, SeuratObject, Matrix,
  tidyverse, patchwork,
  SingleCellExperiment, scater, scuttle, scDblFinder,
  harmony,
  svglite,
  BiocParallel,
  glmGamPoi
)

use_bpcells   <- requireNamespace("BPCells", quietly = TRUE)
use_hdf5array <- requireNamespace("HDF5Array", quietly = TRUE) && requireNamespace("DelayedArray", quietly = TRUE)
have_lisi     <- requireNamespace("lisi", quietly = TRUE)

have_leiden <- requireNamespace("reticulate", quietly = TRUE) &&
               tryCatch(reticulate::py_module_available("leidenalg"), error = function(e) FALSE)
algo <- if (have_leiden) 4L else 3L # 4 = Leiden, 3 = Louvain (smart)

immune_panel <- c(
  "CCR7","IL7R","LEF1","TCF7","LTB",
  "CD3D","CD3E","CD3G","CD4","TBX21","CXCR3","IL12RB2","CCR5",
  "GATA3","CCR4","PTGDR2","RORC","CCR6","IL23R","IL2RA","FOXP3","CTLA4",
  "CD8A","NKG7","GNLY","GZMB","PRF1",
  "MS4A1","CD79A","TCL1A","IGHD","CD74",
  "HLA-DQA1","IGHG1",
  "LYZ","S100A9","CD14","LGALS3","FCGR3A",
  "CD1C","FCER1A","CLEC10A","IRF4",
  "IL3RA","CLEC4C","TCF4"
)

BiocParallel::register(BiocParallel::MulticoreParam(workers = 1))

theme_set(ggplot2::theme_minimal(base_size = 14))

# Unified saver
save_both <- function(plot_obj, filebase, width = 16, height = 9, dpi = 600, bg = "white") {
  ggplot2::ggsave(paste0(filebase, ".png"), plot_obj, width = width, height = height, dpi = dpi, bg = bg)
  ggplot2::ggsave(paste0(filebase, ".svg"), plot_obj, width = width, height = height, dpi = dpi, bg = bg)
}
```

## 2) Paths & helpers

```{r}
h5_dir      <- "/home/jacky/scRNASeq_Steffi/filtered_matrices"
project_dir <- "/home/jacky/scRNASeq_Steffi/analysis_outputs_downsample1000_5"

for (d in c("tables","rds","plots","logs")) dir.create(file.path(project_dir, d), recursive = TRUE, showWarnings = FALSE)
meta_dir  <- file.path(project_dir, "tables")
rds_dir   <- file.path(project_dir, "rds")
plots_dir <- file.path(project_dir, "plots")

stop_quiet <- function(cond, msg) { if (!isTRUE(cond)) stop(msg, call. = FALSE) }

make_res_dirs <- function(root, res_label) {
  res_dir   <- file.path(root, paste0("res_", res_label))
  d_plots   <- file.path(res_dir, "plots")
  d_markers <- file.path(res_dir, "markers")
  d_qc      <- file.path(res_dir, "qc")
  d_meta    <- file.path(res_dir, "metadata")
  d_pb      <- file.path(res_dir, "pseudobulk")
  d_de      <- file.path(res_dir, "de_results")
  d_ann     <- file.path(res_dir, "annotations")
  dir.create(d_plots,   recursive = TRUE, showWarnings = FALSE)
  dir.create(d_markers, recursive = TRUE, showWarnings = FALSE)
  dir.create(d_qc,      recursive = TRUE, showWarnings = FALSE)
  dir.create(d_meta,    recursive = TRUE, showWarnings = FALSE)
  dir.create(d_pb,      recursive = TRUE, showWarnings = FALSE)
  dir.create(d_de,      recursive = TRUE, showWarnings = FALSE)
  dir.create(d_ann,     recursive = TRUE, showWarnings = FALSE)
  list(res_dir = res_dir, plots = d_plots, markers = d_markers, qc = d_qc, meta = d_meta, pb = d_pb, de = d_de, ann = d_ann)
}

sample_pal <- function(x) {
  f <- factor(x)
  out <- tryCatch(grDevices::hcl.colors(nlevels(f), palette = "Set2"),
                  error = function(e) grDevices::hcl.colors(nlevels(f)))
  out
}

stop_quiet(dir.exists(h5_dir), paste0("Missing h5_dir: ", h5_dir))
```

## 3) Discover inputs

```{r}
h5_files <- list.files(h5_dir, pattern = "*.h5$", full.names = TRUE, recursive = TRUE)
stop_quiet(length(h5_files) > 0, paste0("No .h5 files under ", h5_dir))

parse_info <- function(fp){
  parts <- strsplit(tools::file_path_sans_ext(basename(fp)), "_", fixed = TRUE)[[1]]
  tibble::tibble(file = fp, sample = paste0(parts[1], "_", parts[2]), donor = parts[1], condition = parts[2])
}
info <- purrr::map_dfr(h5_files, parse_info)
readr::write_csv(info, file.path(meta_dir, "samples_parsed.csv"))
print(info, n = nrow(info))
```

## 4) Read & merge

```{r}
objs <- lapply(seq_len(nrow(info)), function(i){
  message("Reading: ", basename(info$file[i]))
  mat <- Read10X_h5(info$file[i])
  so  <- CreateSeuratObject(counts = mat, project = info$donor[i], min.cells = 3, min.features = 200)
  so$sample    <- info$sample[i]
  so$donor     <- info$donor[i]
  so$condition <- info$condition[i]
  colnames(so) <- paste(info$sample[i], colnames(so), sep = "_")
  so
})
stop_quiet(length(objs) > 0, "No Seurat objects created.")
obj <- Reduce(function(a, b) merge(a, b), objs)
obj <- JoinLayers(obj, assay = "RNA")
stop_quiet(inherits(obj, "Seurat"), "obj not Seurat after merge")
saveRDS(obj, file.path(rds_dir, "00_merged_raw.rds"))
```

## Check immune panel

```{r}
intersect(immune_panel, rownames(obj))
```

## Downsample the SO for speed

```{r}
orig_idents <- Idents(obj)
Idents(obj)  <- obj$sample
obj          <- subset(x = obj, downsample = 1000)
Idents(obj)  <- orig_idents
message("Cells after per-sample downsample: ", ncol(obj))
```

## 5) QC visuals (pre-filter)

```{r}
DefaultAssay(obj) <- "RNA"
obj[["percent.mt"]] <- PercentageFeatureSet(obj, pattern = "^MT-")
ribolist <- grep("^RP[SL]", rownames(obj), value = TRUE)
ribolist_clean <- setdiff(ribolist, c("RPS19BP1", "RPS6KA3", "RPS6KA2-AS1"))
obj[["percent.ribo"]] <- PercentageFeatureSet(obj, features = ribolist_clean)

obj$sample <- factor(obj$sample)
pal <- sample_pal(obj$sample)

qc_feats <- c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.ribo")
qc_titles <- c(
  nFeature_RNA = "Genes per cell",
  nCount_RNA   = "UMIs per cell",
  `percent.mt` = "Mitochondrial percentage",
  `percent.ribo` = "Ribosomal percentage"
)

mk_vln <- function(feat) {
  p <- VlnPlot(
    obj, features = feat, group.by = "sample", cols = pal, pt.size = 0
  ) +
    ggplot2::stat_summary(
      fun.data = function(y) data.frame(y = mean(y), ymin = mean(y), ymax = mean(y)),
      geom = "errorbar", width = 0.15, linewidth = 0.35, color = "black"
    ) +
    ggplot2::ggtitle(qc_titles[[feat]]) +
    ggplot2::theme_minimal(base_size = 14) +
    ggplot2::theme(
      axis.text.x = ggplot2::element_text(angle = 45, hjust = 1, vjust = 1),
      panel.grid.minor = ggplot2::element_blank(),
      panel.grid.major.x = ggplot2::element_blank(),
      strip.text = ggplot2::element_text(face = "bold"),
      plot.title = ggplot2::element_text(face = "bold"),
      legend.position = "none",
      axis.title.x = ggplot2::element_blank(),
      axis.title.y = ggplot2::element_blank()
    )
  if (feat == "percent.mt") p <- p + ggplot2::coord_cartesian(ylim = c(0, 25))
  if (feat == "nCount_RNA") p <- p + ggplot2::coord_cartesian(ylim = c(0, 75000))
  p
}

plots <- lapply(qc_feats, mk_vln)
p_vln <- (plots[[1]] | plots[[2]]) / (plots[[3]] | plots[[4]])
p_vln <- p_vln + patchwork::plot_annotation(title = "QC metrics per sample (means shown)")
save_both(p_vln, file.path(plots_dir, "qc_violin_raw_final"))

p_sc1 <- FeatureScatter(
  obj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", pt.size = 0.2
) +
  ggplot2::labs(title = "Genes vs UMIs per cell", x = "UMIs per cell", y = "Genes per cell") +
  ggplot2::scale_x_continuous(labels = scales::comma, limits = c(0, 75000)) +
  ggplot2::theme_minimal(base_size = 14) +
  ggplot2::theme(legend.position = "none")

p_sc2 <- FeatureScatter(
  obj, feature1 = "nCount_RNA", feature2 = "percent.mt", pt.size = 0.2
) +
  ggplot2::labs(title = "Mitochondrial % vs UMIs per cell", x = "UMIs per cell", y = "Mitochondrial %") +
  ggplot2::scale_x_continuous(labels = scales::comma, limits = c(0, 75000)) +
  ggplot2::scale_y_continuous(limits = c(0, 25)) +
  ggplot2::theme_minimal(base_size = 14) +
  ggplot2::theme(legend.position = "none")

save_both(p_sc1 + p_sc2, file.path(plots_dir, "qc_scatter_raw_labeled"))
```

## 6) On-disk backend 

```{r}
# Extract original counts BEFORE converting to BPCells
counts_raw <- SeuratObject::LayerData(obj[["RNA"]], layer = "counts")

# Realize to memory if needed (BPCells and other backends produce DelayedMatrix)
if (!inherits(counts_raw, "dgCMatrix")) {
  message("Realizing RNA counts into memory for SingleR compatibility...")
  counts_raw <- as(Matrix::Matrix(as.matrix(counts_raw), sparse = TRUE), "dgCMatrix")
}

# Store the realized counts back into the RNA assay (for SingleR later)
obj[["RNA"]] <- SeuratObject::SetAssayData(
  obj[["RNA"]],
  slot     = "counts",
  new.data = counts_raw
)

# Save this version (safe checkpoint)
saveRDS(obj, file.path(rds_dir, "00b_realized_counts_before_backend.rds"))


### ---------- Now activate BPCells backend ---------- ###

if (use_bpcells) {
  message("Activating BPCells backend...")

  bp_dir <- file.path(project_dir, "bp_backend", "RNA_counts")
  if (dir.exists(bp_dir)) unlink(bp_dir, recursive = TRUE)
  dir.create(bp_dir, recursive = TRUE, showWarnings = FALSE)

  # IMPORTANT: use the realized dgCMatrix, NOT the delayed matrix
  BPCells::write_matrix_dir(mat = counts_raw, dir = bp_dir, overwrite = TRUE)

  # Replace Seurat RNA counts layer with on-disk BPCells matrix
  SeuratObject::LayerData(obj[["RNA"]], layer = "counts") <- BPCells::open_matrix_dir(dir = bp_dir)

  message("BPCells counts layer active")
}

# (optional fallback)
if (!use_bpcells && use_hdf5array) {
  if (!requireNamespace("rhdf5", quietly = TRUE)) {
    if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
    BiocManager::install("rhdf5", ask = FALSE, update = FALSE)
  }
  library(HDF5Array); library(DelayedArray)

  h5_path <- file.path(project_dir, "HDF5_backend_counts.h5")
  if (file.exists(h5_path)) { try({ rhdf5::h5closeAll() }, silent = TRUE); unlink(h5_path) }

  counts_h5 <- HDF5Array::writeHDF5Array(
    counts_raw,
    filepath = h5_path,
    name = "counts",
    chunkdim = pmin(dim(counts_raw), c(1000, 1000))
  )

  SeuratObject::LayerData(obj[["RNA"]], layer = "counts") <- counts_h5
  message("HDF5Array counts layer active")
}
```

## 7) Doublets (optional; off by default)

```{r}
# Uncomment for per-sample doublet detection:
# obj <- scDblFinder::scDblFinder(obj, samples = obj$sample, BPPARAM = BiocParallel::bpparam())
```

## 8) QC filtering with robust outlier rules

```{r}
is_outlier_local <- function(x, nmads = 3, type = c("both", "lower", "higher")) {
  type <- match.arg(type)
  out <- scater::isOutlier(x, nmads = nmads, type = type, log = FALSE)
  out[is.na(out)] <- FALSE
  out
}

cells_keep <- (!is_outlier_local(obj$nFeature_RNA, type = "lower")) &
              (!is_outlier_local(obj$nCount_RNA,   type = "higher")) &
              (!is_outlier_local(obj$percent.mt,   type = "higher")) &
              (!is_outlier_local(obj$percent.ribo, type = "higher"))
cells_keep[is.na(cells_keep)] <- FALSE

obj <- subset(obj, cells = colnames(obj)[cells_keep])
stop_quiet(inherits(obj, "Seurat"), "obj not Seurat after QC filter")
saveRDS(obj, file.path(rds_dir, "01b_after_qc_filter.rds"))
```

## 9) SCTransform v2 (glmGamPoi)

```{r}
DefaultAssay(obj) <- "RNA"
obj <- SCTransform(
  object = obj,
  vst.flavor = "v2",
  variable.features.n = 2000,
  method = "glmGamPoi"
)
stop_quiet(DefaultAssay(obj) == "SCT", "SCT not set as default after SCTransform")
saveRDS(obj, file.path(rds_dir, "02_sct.rds"))
```

## 10) PCA + diagnostics + UMAP (pre-Harmony)

```{r}
library(ggplot2); library(dplyr); library(tibble); library(patchwork); library(readr)

message("Running PCA (npcs = 50)...")
obj <- RunPCA(obj, npcs = 50, verbose = FALSE)
stopifnot("pca" %in% names(obj@reductions))

shared_base <- 14
shared_theme <- theme_minimal(base_size = shared_base) +
theme(
  plot.title = element_text(face = "bold", size = shared_base + 2, hjust = 0.5),
  axis.title = element_text(size = shared_base - 1),
  axis.text  = element_text(size = shared_base - 2),
  panel.grid.major = element_line(color = "grey90", size = 0.35),
  panel.grid.minor = element_blank()
)

# Elbow
p_elbow <- tryCatch({
  ElbowPlot(obj, ndims = 50) +
    labs(title = "Classic PCA elbow (SD)") +
    shared_theme
}, error = function(e) {
  sdev_fallback <- as.numeric(obj@reductions$pca@stdev)
  df_sd <- tibble(PC = seq_along(sdev_fallback), SD = sdev_fallback)
  ggplot(df_sd, aes(PC, SD)) + geom_point(size = 1.8) + geom_line() +
    labs(title = "Classic PCA elbow (SD)", x = "PC", y = "SD") + shared_theme
})

# Scree
sdev <- as.numeric(obj@reductions$pca@stdev)
var_explained <- (sdev^2) / sum(sdev^2) * 100
cumvar <- cumsum(var_explained)
npcs <- length(var_explained)
df_scree <- tibble(PC = seq_len(npcs), Var = var_explained, CumVar = cumvar)
p_scree <- ggplot(df_scree, aes(x = PC)) +
  geom_col(aes(y = Var), width = 0.7) +
  geom_point(aes(y = Var), size = 1.8) +
  geom_line(aes(y = CumVar), size = 1.1) +
  scale_x_continuous(breaks = seq(0, min(npcs, 50), by = 5)) +
  scale_y_continuous(name = "Variance explained (%)",
                     sec.axis = sec_axis(~ ., name = "Cumulative variance (%)")) +
  labs(title = "Scree: % variance per PC + cumulative", x = "Principal component") + shared_theme

# Loadings
loadings_mat <- Seurat::Loadings(obj, reduction = "pca")
plot_top_loadings <- function(pc, n = 15, mat = loadings_mat) {
  df <- data.frame(gene = rownames(mat), loading = as.numeric(mat[, pc]), stringsAsFactors = FALSE) |>
    dplyr::mutate(abs_loading = abs(loading)) |>
    dplyr::arrange(desc(abs_loading)) |>
    dplyr::slice_head(n = n)
  df$gene <- factor(df$gene, levels = rev(df$gene))
  p <- ggplot(df, aes(x = gene, y = loading, fill = loading > 0)) +
    geom_col() + coord_flip() +
    labs(title = paste0("PC", pc, " — top ", n, " absolute loadings"),
         x = NULL, y = "Loading") +
    theme_minimal(base_size = shared_base - 1) +
    theme(legend.position = "none", plot.title = element_text(face = "bold"))
  list(plot = p, tbl = df)
}
p_pc1 <- plot_top_loadings(1)$plot; p_pc2 <- plot_top_loadings(2)$plot

# Compose & save
combined <- ((p_elbow + p_scree) / (p_pc1 + p_pc2))
save_both(combined, file.path(plots_dir, "PCA_diagnostics"), width = 16, height = 10.5, dpi = 600)

# Pre-Harmony UMAP in PCA space
dims_pca <- 1:30
obj <- RunUMAP(obj, reduction = "pca", dims = dims_pca,
               n.neighbors = 30, min.dist = 0.3, seed.use = 156,
               umap.method = "uwot", metric = "cosine", return.model = FALSE,
               reduction.name = "umap_pca")

save_both(DimPlot(obj, reduction = "umap_pca", group.by = "sample", raster = TRUE, pt.size = 0.5) + shared_theme,
          file.path(plots_dir, "UMAP_preHarmony_by_sample"), width = 9, height = 9)
save_both(DimPlot(obj, reduction = "umap_pca", group.by = "donor", raster = TRUE, pt.size = 0.5) + shared_theme,
          file.path(plots_dir, "UMAP_preHarmony_by_donor"),  width = 9, height = 9)
save_both(DimPlot(obj, reduction = "umap_pca", group.by = "condition", raster = TRUE, pt.size = 0.5) + shared_theme,
          file.path(plots_dir, "UMAP_preHarmony_by_condition"), width = 9, height = 9)
```

## 11) Harmony integration + UMAP (Harmony space)

```{r}
stop_quiet("pca" %in% names(obj@reductions), "PCA reduction missing — run RunPCA first.")
stop_quiet("donor" %in% colnames(obj@meta.data), "Metadata lacks 'donor' column.")

npcs     <- ncol(Embeddings(obj, "pca"))
stop_quiet(npcs > 0, "PCA has zero components.")
dims_use <- base::seq_len(base::min(40, npcs))

obj <- harmony::RunHarmony(
  object         = obj,
  group.by.vars  = "donor",
  reduction.use  = "pca",
  dims.use       = dims_use,
  assay.use      = DefaultAssay(obj),
  reduction.save = "harmony",
  project.dim    = TRUE,
  verbose        = FALSE
)
stop_quiet("harmony" %in% names(obj@reductions), "Harmony reduction missing after RunHarmony.")
saveRDS(obj, file.path(rds_dir, "03_after_harmony.rds"))

umap_dims <- base::seq_len(base::min(30, ncol(Embeddings(obj, "harmony"))))
obj <- RunUMAP(
  obj, reduction = "harmony", dims = umap_dims,
  n.neighbors = 30, min.dist = 0.3, seed.use = 156,
  umap.method = "uwot", metric = "cosine", return.model = FALSE,
  reduction.name = "umap_harmony"
)

save_both(DimPlot(obj, reduction = "umap_harmony", group.by = "sample", raster = TRUE, pt.size = 0.5),
          file.path(plots_dir, "UMAP_harmony_by_sample"),   width = 9, height = 9)
save_both(DimPlot(obj, reduction = "umap_harmony", group.by = "donor", raster = TRUE, pt.size = 0.5),
          file.path(plots_dir, "UMAP_harmony_by_donor"),    width = 9, height = 9)
save_both(DimPlot(obj, reduction = "umap_harmony", group.by = "condition", raster = TRUE, pt.size = 0.5),
          file.path(plots_dir, "UMAP_harmony_by_condition"), width = 9, height = 9)

if (have_lisi) {
  emb  <- as.data.frame(Embeddings(obj, "harmony"))
  meta <- obj@meta.data[, c("donor","condition"), drop = FALSE]
  lisi_res <- lisi::compute_lisi(emb, meta, label_colnames = c("donor","condition"))
  readr::write_csv(as.data.frame(lisi_res), file.path(meta_dir, "lisi_scores_harmony.csv"))
}
```

## 12) Neighbors (Harmony space; required before clustering)

```{r}
dims_use <- base::seq_len(base::min(30, ncol(Embeddings(obj, "harmony"))))
obj <- FindNeighbors(obj, reduction = "harmony", dims = dims_use,
                     k.param = 30, graph.name = "harmony_nn", verbose = FALSE)
```

## 13) Clustering & marker plots per resolution (0.1, 0.2, 0.5)

```{r}
DefaultAssay(obj) <- "SCT"

.ensure_harmony_nn_umap <- function(x) {
  if (!"harmony" %in% names(x@reductions)) {
    stop("Harmony reduction missing; run ## 11 first.", call. = FALSE)
  }

  dims_use <- base::seq_len(base::min(30, ncol(Embeddings(x, "harmony"))))

  if (!"harmony_nn" %in% names(x@graphs)) {
    x <- FindNeighbors(
      x, reduction = "harmony", dims = dims_use,
      k.param = 30, graph.name = "harmony_nn", verbose = FALSE
    )
  }

  if (!"umap_harmony" %in% names(x@reductions)) {
    x <- RunUMAP(
      x, reduction = "harmony", dims = dims_use,
      n.neighbors = 30, min.dist = 0.3, seed.use = 156,
      umap.method = "uwot", metric = "cosine",
      return.model = FALSE, reduction.name = "umap_harmony"
    )
  }

  x
}

cluster_one_resolution <- function(x, r, algo) {
  x <- .ensure_harmony_nn_umap(x)

  # clustering
  x <- FindClusters(
    x, graph.name = "harmony_nn",
    resolution = r, algorithm = algo, verbose = FALSE
  )

  cl_col <- sprintf("seurat_clusters_res.%s", r)
  x[[cl_col]] <- factor(as.character(Idents(x)))
  Idents(x) <- cl_col

  dirs <- make_res_dirs(project_dir, as.character(r))

  ## UMAPs
  p1 <- DimPlot(
    x, reduction = "umap_harmony", group.by = cl_col,
    label = TRUE, repel = TRUE, raster = TRUE, pt.size = 0.5
  )
  p2 <- DimPlot(
    x, reduction = "umap_harmony", group.by = "sample",
    raster = TRUE, pt.size = 0.5
  )
  p3 <- DimPlot(
    x, reduction = "umap_harmony", split.by = "sample",
    raster = TRUE, pt.size = 0.3
  )

  save_both(p1, file.path(dirs$plots, sprintf("UMAP_clusters_res%s", r)), width = 9, height = 9)
  save_both(p2, file.path(dirs$plots, sprintf("UMAP_by_sample_res%s", r)), width = 9, height = 9)
  save_both(p3, file.path(dirs$plots, sprintf("UMAP_split_by_sample_res%s", r)), width = 9, height = 9)

  ## Find markers (SCT)
  DefaultAssay(x) <- "SCT"
  markers <- tryCatch(
    FindAllMarkers(
      x, assay = "SCT", only.pos = TRUE,
      min.pct = 0.1, logfc.threshold = 0.15,
      test.use = "wilcox", max.cells.per.ident = 1000, random.seed = 156
    ),
    error = function(e) {
      warning("FindAllMarkers failed for res=", r, ": ", conditionMessage(e))
      tibble::tibble()
    }
  )
  readr::write_csv(markers, file.path(dirs$markers, sprintf("cluster_markers_res%s.csv", r)))

  ## Top10 heatmap / dotplot per cluster
  if (nrow(markers) > 0) {
    top_markers <- markers %>%
      dplyr::group_by(cluster) %>%
      dplyr::slice_max(order_by = avg_log2FC, n = 10, with_ties = FALSE) %>%
      dplyr::ungroup() %>%
      dplyr::pull(gene) %>%
      unique()

    hm_feats <- intersect(top_markers, rownames(x))

    if (length(hm_feats) >= 2) {
      suppressWarnings({
        x <- ScaleData(
          x, assay = DefaultAssay(x), features = hm_feats,
          verbose = FALSE, clip.max = 3
        )
      })

      p_heat <- DoHeatmap(
        x, features = hm_feats, assay = DefaultAssay(x),
        slot = "scale.data", raster = TRUE
      )
      save_both(p_heat, file.path(dirs$plots, sprintf("Heatmap_top10_markers_res%s", r)))

      p_dot <- DotPlot(
        x, features = hm_feats, group.by = cl_col,
        scale.by = "size", dot.min = 0.1
      ) +
        ggplot2::theme(
          axis.text.x = ggplot2::element_text(angle = 90, hjust = 1)
        )
      save_both(p_dot, file.path(dirs$plots, sprintf("DotPlot_top_markers_res%s", r)))
    }

    ## Per-cluster violin plots for top 6 DE genes
    for (cl in levels(Idents(x))) {
      genes_cl <- markers %>%
        dplyr::filter(cluster == cl) %>%
        dplyr::slice_max(order_by = avg_log2FC, n = 6, with_ties = FALSE) %>%
        dplyr::pull(gene) %>%
        intersect(rownames(x))

      if (length(genes_cl)) {
        p_vln <- VlnPlot(
          x, features = genes_cl, group.by = cl_col,
          pt.size = 0, ncol = min(3, length(genes_cl))
        )
        save_both(
          p_vln,
          file.path(
            dirs$plots,
            sprintf("VlnPlot_top_markers_cluster_%s_res%s", cl, r)
          )
        )
      }
    }
  }

  ## IMMUNE PANEL: dotplot + heatmap + UMAP + violins
  DefaultAssay(x) <- "SCT"
  panel_feats <- intersect(immune_panel, rownames(x))

  if (length(panel_feats) > 0) {
    suppressWarnings({
      x <- ScaleData(
        x, assay = DefaultAssay(x),
        features = panel_feats, verbose = FALSE, clip.max = 3
      )
    })

    # Dotplot
    p_panel_dot <- DotPlot(
      x, features = panel_feats, group.by = cl_col,
      scale.by = "size", dot.min = 0.05
    ) +
      ggplot2::ggtitle(sprintf("Immune marker panel — res=%s", r)) +
      ggplot2::theme(
        axis.text.x = ggplot2::element_text(angle = 90, hjust = 1)
      )
    save_both(
      p_panel_dot,
      file.path(dirs$plots, sprintf("DotPlot_immune_panel_res%s", r)),
      width = 16, height = 9
    )

    # Heatmap
    p_panel_heat <- DoHeatmap(
      x, features = panel_feats,
      assay = DefaultAssay(x), slot = "scale.data", raster = TRUE
    ) +
      ggplot2::ggtitle(sprintf("Immune marker heatmap — res=%s", r))
    save_both(
      p_panel_heat,
      file.path(dirs$plots, sprintf("Heatmap_immune_panel_res%s", r)),
      width = 16, height = 9
    )

    # Violin plots for immune panel genes
    p_panel_vln <- VlnPlot(
      x, features = panel_feats, group.by = cl_col,
      pt.size = 0, ncol = min(4, length(panel_feats))
    )
    save_both(
      p_panel_vln,
      file.path(dirs$plots, sprintf("VlnPlot_immune_panel_res%s", r)),
      width = 16, height = 9
    )

    # UMAP feature plots per immune gene
    for (g in panel_feats) {
      p_feat <- FeaturePlot(
        x, features = g, reduction = "umap_harmony",
        order = TRUE, pt.size = 0.3
      ) +
        ggplot2::ggtitle(sprintf("%s — res=%s", g, r))
      safe_g <- gsub("[^A-Za-z0-9]+", "_", g)
      save_both(
        p_feat,
        file.path(dirs$plots,
                  sprintf("UMAP_immune_%s_res%s", safe_g, r)),
        width = 9, height = 9
      )
    }
  }

  ## basic metadata export
  meta_res <- x@meta.data %>%
    tibble::rownames_to_column("cell_id") %>%
    dplyr::mutate(cluster = as.character(.data[[cl_col]]))

  prop_tbl <- meta_res %>%
    dplyr::count(donor, condition, cluster, name = "cells") %>%
    dplyr::group_by(donor, condition) %>%
    dplyr::mutate(prop = cells / sum(cells)) %>%
    dplyr::ungroup()

  readr::write_csv(
    prop_tbl,
    file.path(dirs$meta, sprintf("proportions_by_donor_condition_res%s.csv", r))
  )
  readr::write_csv(
    meta_res,
    file.path(dirs$meta, sprintf("metadata_res%s.csv", r))
  )

  x
}

## run clustering for the three resolutions
obj <- cluster_one_resolution(obj, r = 0.1, algo = algo)
saveRDS(obj, file.path(rds_dir, "04_postIntegration_res0.1.rds"))

obj <- cluster_one_resolution(obj, r = 0.2, algo = algo)
saveRDS(obj, file.path(rds_dir, "04_postIntegration_res0.2.rds"))
obj <- cluster_one_resolution(obj, r = 0.5, algo = algo)
saveRDS(obj, file.path(rds_dir, "04_postIntegration_res0.5.rds"))

```

### annotate the crued clusters 




## 14) SingleR: per-cell annotations per resolution (robust with fallbacks)
```{r}
 # Build a SingleR-ready object:
# - clustering, UMAP, SCT etc. from processed object (with BPCells)
# - plain in-memory counts from the 00b object (no BPCells)

obj_backend <- readRDS(file.path(rds_dir, "04_postIntegration_res0.5.rds"))
obj_counts  <- readRDS(file.path(rds_dir, "00b_realized_counts_before_backend.rds"))

# restrict to common cells (00b is pre-QC, 04 is post-QC)
common_cells <- intersect(colnames(obj_backend), colnames(obj_counts))
stop_quiet(length(common_cells) > 0,
           "No overlapping cells between processed object and 00b counts object.")

obj_backend <- obj_backend[, common_cells]
obj_counts  <- obj_counts[, common_cells]

# take in-memory RNA counts from 00b object
counts_mem <- SeuratObject::GetAssayData(obj_counts, assay = "RNA", slot = "counts")
# (should already be dgCMatrix, but be defensive)
if (!inherits(counts_mem, "dgCMatrix")) {
  message("Coercing RNA counts to sparse dgCMatrix for SingleR...")
  counts_mem <- as(Matrix::Matrix(as.matrix(counts_mem), sparse = TRUE), "dgCMatrix")
}

# overwrite RNA counts in the processed object with the in-memory counts
SeuratObject::LayerData(obj_backend[["RNA"]], layer = "counts") <- counts_mem

# this hybrid object has:
# - RNA counts as in-memory dgCMatrix
# - SCT assay, Harmony, UMAP, clustering columns etc. from the processed run
obj <- obj_backend
rm(obj_backend, obj_counts, counts_mem, common_cells)

pkgs <- c(
  "SingleR","celldex","SingleCellExperiment","SummarizedExperiment",
  "scater","edgeR","S4Vectors"
)
for (p in pkgs) if (!requireNamespace(p, quietly = TRUE)) {
  if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
  BiocManager::install(p, ask = FALSE, update = FALSE)
}
suppressPackageStartupMessages({
  library(SingleR); library(celldex); library(SingleCellExperiment)
  library(SummarizedExperiment); library(scater); library(edgeR)
  library(S4Vectors)
})

## Load celldex references (soft; never stop the pipeline)
ref_monaco    <- try(celldex::MonacoImmuneData(),    silent = TRUE); if (inherits(ref_monaco,    "try-error")) ref_monaco    <- NULL
ref_blueprint <- try(celldex::BlueprintEncodeData(), silent = TRUE); if (inherits(ref_blueprint, "try-error")) ref_blueprint <- NULL

## Helper: build SCE from Seurat WITHOUT touching meta.data
build_sce_from_seurat <- function(seurat_obj, assay = "RNA") {
  counts <- SeuratObject::GetAssayData(seurat_obj, assay = assay, slot = "counts")
  meta   <- seurat_obj[[]]

  SingleCellExperiment::SingleCellExperiment(
    assays  = list(counts = counts),
    colData = S4Vectors::DataFrame(meta)
  )
}

.overlap_ok <- function(sym_vec, ref) length(intersect(sym_vec, rownames(ref)))

annot_one_resolution <- function(obj, r) {
  dirs        <- make_res_dirs(project_dir, as.character(r))
  cluster_col <- sprintf("seurat_clusters_res.%s", r)
  label_col   <- sprintf("celltype_res%s_auto", gsub("\\.", "", as.character(r)))

  stop_quiet(cluster_col %in% colnames(obj[[]]),
             paste0("Missing clustering column: ", cluster_col))

  Idents(obj)       <- cluster_col
  DefaultAssay(obj) <- "RNA"

  ## Try to build SCE; if this fails, fall back to clusters as labels
  sce <- tryCatch(
    build_sce_from_seurat(obj, assay = "RNA"),
    error = function(e) {
      warning("Failed to build SingleCellExperiment for res=", r,
              ". Using clusters as labels only. Error: ", conditionMessage(e))
      obj[[label_col]] <- obj[[cluster_col]]

      umap_name <- if ("umap_harmony" %in% names(obj@reductions)) "umap_harmony" else "umap_pca"
      p_umap <- DimPlot(obj, reduction = umap_name, group.by = label_col,
                        label = TRUE, repel = TRUE, pt.size = 0.5) +
        ggplot2::ggtitle(label_col)
      save_both(p_umap, file.path(dirs$ann, paste0("UMAP_", label_col)), width = 9, height = 9)

      readr::write_csv(
        obj[[]] %>% tibble::rownames_to_column("cell_id"),
        file.path(dirs$ann, paste0("seurat_meta_with_", label_col, ".csv"))
      )

      return(NULL)
    }
  )
  if (is.null(sce)) return(obj)

  ## If we have no references at all, just label by clusters
  if (is.null(ref_monaco) && is.null(ref_blueprint)) {
    warning("No celldex references available. Skipping SingleR for res=", r,
            " and using clusters as labels.")
    obj[[label_col]] <- obj[[cluster_col]]
  } else {
    sym <- rownames(sce)
    ov1 <- if (!is.null(ref_monaco))    .overlap_ok(sym, ref_monaco)    else 0L
    ov2 <- if (!is.null(ref_blueprint)) .overlap_ok(sym, ref_blueprint) else 0L

    if (max(ov1, ov2) < 200) {
      warning("Too little gene overlap (Monaco=", ov1, ", Blueprint=", ov2,
              "). Skipping SingleR for res=", r, " and using clusters as labels.")
      obj[[label_col]] <- obj[[cluster_col]]
    } else {
      pred1 <- if (!is.null(ref_monaco)) {
        tryCatch(
          SingleR(
            test            = sce,
            ref             = ref_monaco,
            labels          = ref_monaco$label.fine,
            assay.type.test = "counts",
            assay.type.ref  = "logcounts",
            fine.tune       = TRUE,
            de.method       = "wilcox",
            BPPARAM         = BiocParallel::SerialParam(),
            prune           = TRUE
          ),
          error = function(e) {
            warning("SingleR (Monaco) failed for res=", r, ": ", conditionMessage(e))
            NULL
          }
        )
      } else NULL

      pred2 <- if (!is.null(ref_blueprint)) {
        tryCatch(
          SingleR(
            test            = sce,
            ref             = ref_blueprint,
            labels          = ref_blueprint$label.main,
            assay.type.test = "counts",
            assay.type.ref  = "logcounts",
            fine.tune       = TRUE,
            de.method       = "wilcox",
            BPPARAM         = BiocParallel::SerialParam(),
            prune           = TRUE
          ),
          error = function(e) {
            warning("SingleR (BlueprintEncode) failed for res=", r, ": ", conditionMessage(e))
            NULL
          }
        )
      } else NULL

      labels1 <- if (!is.null(pred1) && !is.null(pred1$labels)) {
        x <- pred1$labels; names(x) <- colnames(sce); x
      } else NULL
      labels2 <- if (!is.null(pred2) && !is.null(pred2$labels)) {
        x <- pred2$labels; names(x) <- colnames(sce); x
      } else NULL

      combined <- if (!is.null(labels1) && !is.null(labels2)) {
        out <- labels1
        out[is.na(out)] <- labels2[is.na(out)]
        out
      } else if (!is.null(labels1)) {
        labels1
      } else {
        labels2
      }

      if (is.null(combined)) {
        warning("SingleR returned no usable labels for res=", r,
                ". Using clusters as labels.")
        obj[[label_col]] <- obj[[cluster_col]]
      } else {
        combined <- combined[colnames(sce)]
        combined[is.na(combined)] <- "Unknown"
        obj[[label_col]] <- factor(combined[colnames(obj)])
      }
    }
  }

  umap_name <- if ("umap_harmony" %in% names(obj@reductions)) "umap_harmony" else "umap_pca"
  p_umap <- DimPlot(obj, reduction = umap_name, group.by = label_col,
                    label = TRUE, repel = TRUE, pt.size = 0.5) +
    ggplot2::ggtitle(label_col)
  save_both(p_umap, file.path(dirs$ann, paste0("UMAP_", label_col)), width = 9, height = 9)

  readr::write_csv(
    obj[[]] %>% tibble::rownames_to_column("cell_id"),
    file.path(dirs$ann, paste0("seurat_meta_with_", label_col, ".csv"))
  )

  obj
}

## Run per resolution and save updated objects
for (r in c(0.1, 0.2, 0.5)) {
  message("Running SingleR / annotation for res=", r)
  obj <- annot_one_resolution(obj, r)
  saveRDS(obj, file.path(rds_dir, sprintf("05_after_SingleR_res%s.rds", r)))
}
```

## 15) Pseudobulk aggregation per resolution & cell type

```{r}
## 15) Pseudobulk aggregation per resolution & cell type

# Always start from the SingleR-annotated hybrid object.
# This file was saved in ## 14 after running SingleR for all resolutions.
obj <- readRDS(file.path(rds_dir, "05_after_SingleR_res0.5.rds"))
stop_quiet(inherits(obj, "Seurat"), "obj is not a Seurat object in ## 15")

DefaultAssay(obj) <- "RNA"

pseudo_min_cpm <- 1
pseudo_min_smp <- 2

healthy_donors  <- c("NB166","NB171","NB172")
diseased_donors <- c("AD200","AD201","NB175")

# Resolutions we care about
resolutions <- c(0.1, 0.2, 0.5)

# Corresponding label columns – NOTE the double backslash for the regex:
# gsub("\\.", "", ...) turns "0.1" -> "01"
label_cols  <- vapply(
  resolutions,
  function(r) sprintf("celltype_res%s_auto", gsub("\\.", "", as.character(r))),
  FUN.VALUE = character(1)
)

# Quick sanity check: warn if any label column is missing
for (i in seq_along(resol utions)) {
  if (!label_cols[i] %in% colnames(obj@meta.data)) {
    warning(
      "Label column ", label_cols[i], " missing in metadata. ",
      "Did SingleR for res=", resolutions[i], " complete successfully?"
    )
  }
}

aggregate_pseudobulk_by_label <- function(seurat_obj, label_col, min_cells = 20, out_dir) {
  # If the label column is missing, skip gracefully for this resolution
  if (!label_col %in% colnames(seurat_obj@meta.data)) {
    warning("Skipping pseudobulk for label_col = ", label_col,
            " (column not found in meta.data)")
    return(list())
  }

  meta   <- seurat_obj@meta.data
  counts <- SeuratObject::GetAssayData(seurat_obj, assay = "RNA", slot = "counts")

  # Strong consistency check: counts columns == meta rownames
  if (!all(colnames(counts) == rownames(meta))) {
    stop("Counts / metadata cell order mismatch in aggregate_pseudobulk_by_label(). ",
         "Check that the Seurat object is not corrupted.")
  }

  stopifnot(all(c("sample","donor","condition") %in% colnames(meta)))

  labs <- as.character(meta[[label_col]])
  labs[is.na(labs)] <- "Unknown"

  dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)

  out <- list()
  for (lab in sort(unique(labs))) {
    sel <- labs == lab
    if (sum(sel) < min_cells) next  # too few cells for this label

    meta_l <- meta[sel, , drop = FALSE]
    cnt_l  <- counts[, sel, drop = FALSE]

    # pseudobulk by sample
    pb <- rowsum(t(cnt_l), group = meta_l$sample)
    pb <- t(pb)

    meta_pb <- meta_l %>%
      dplyr::select(sample, donor, condition) %>%
      dplyr::distinct() %>%
      dplyr::arrange(sample)

    meta_pb <- meta_pb[match(colnames(pb), meta_pb$sample), , drop = FALSE]
    stopifnot(all(meta_pb$sample == colnames(pb)))

    safe_lab <- gsub("[^A-Za-z0-9]+", "_", lab)

    readr::write_csv(
      as.data.frame(pb) %>% tibble::rownames_to_column("gene"),
      file.path(out_dir, sprintf("pb_counts_celltype_%s.csv", safe_lab))
    )
    readr::write_csv(
      meta_pb,
      file.path(out_dir, sprintf("pb_metadata_celltype_%s.csv", safe_lab))
    )

    out[[lab]] <- list(counts = pb, meta = meta_pb)
  }
  out
}

pb_all_res <- list()
for (r in resolutions) {
  label_col <- sprintf("celltype_res%s_auto", gsub("\\.", "", as.character(r)))
  dirs <- make_res_dirs(project_dir, as.character(r))
  message("Aggregating pseudobulk for res=", r, " using ", label_col)
  pb_all_res[[as.character(r)]] <-
    aggregate_pseudobulk_by_label(obj, label_col, min_cells = 20, out_dir = dirs$pb)
}

```

## 16) edgeR DE: IL9 vs wo and IL18 vs wo (per cell type, per resolution)

```{r}
suppressPackageStartupMessages({
  if (!requireNamespace("edgeR", quietly = TRUE)) {
    if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
    BiocManager::install("edgeR", ask = FALSE, update = FALSE)
  }
  library(edgeR); library(ggplot2)
})

run_edger_main_effect <- function(pb_counts, pb_meta, trt) {
  stopifnot(trt %in% c("IL9","IL18"))
  meta <- pb_meta
  keep <- meta$condition %in% c("wo", trt)
  meta <- meta[keep, , drop = FALSE]
  if (nrow(meta) < 3) return(NULL)

  y <- DGEList(counts = pb_counts[, keep, drop = FALSE])
  keep_genes <- rowSums(cpm(y) > pseudo_min_cpm) >= pseudo_min_smp
  if (sum(keep_genes) < 100) return(NULL)
  y <- y[keep_genes, , keep.lib.sizes = FALSE]
  y <- calcNormFactors(y, method = "TMM")

  meta$condition <- factor(meta$condition, levels = c("wo", trt))
  design <- model.matrix(~ 0 + condition, data = meta)
  colnames(design) <- levels(meta$condition)

  y <- estimateDisp(y, design)
  fit <- glmQLFit(y, design, robust = TRUE)

  contr <- makeContrasts(contrasts = paste0(trt, "-wo"), levels = design)
  qlf <- glmQLFTest(fit, contrast = contr)
  tt  <- topTags(qlf, n = Inf)$table
  tt$gene <- rownames(tt)
  tt
}

plot_volcano <- function(tbl, title) {
  df <- tbl
  df$neglog10FDR <- -log10(pmax(df$FDR, .Machine$double.eps))
  ggplot(df, aes(x = logFC, y = neglog10FDR)) +
    geom_point(alpha = 0.6, size = 0.6) +
    geom_hline(yintercept = -log10(0.05), linetype = 2) +
    geom_vline(xintercept = c(-0.25, 0.25), linetype = 2) +
    labs(title = title, x = "logFC", y = "-log10(FDR)") +
    theme_minimal(base_size = 12)
}

for (r in names(pb_all_res)) {
  d <- make_res_dirs(project_dir, r)
  for (lab in names(pb_all_res[[r]])) {
    pb <- pb_all_res[[r]][[lab]]
    for (trt in c("IL9","IL18")) {
      tt <- run_edger_main_effect(pb$counts, pb$meta, trt)
      if (is.null(tt)) next
      out_csv <- file.path(d$de, sprintf("edgeR_main_%s_vs_wo_celltype_%s.csv", trt, gsub("[^A-Za-z0-9]+","_", lab)))
      readr::write_csv(tt, out_csv)
      p <- plot_volcano(tt, sprintf("edgeR: %s vs wo — %s (res=%s)", trt, lab, r))
      save_both(p, file.path(d$de, sprintf("Volcano_edgeR_%s_vs_wo_%s", trt, gsub("[^A-Za-z0-9]+","_", lab))))
    }
  }
}
```

## 17) limma-voom DE: IL9 vs wo and IL18 vs wo (per cell type, per resolution)

```{r}
if (!requireNamespace("limma", quietly = TRUE)) {
  if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
  BiocManager::install("limma", ask = FALSE, update = FALSE)
}
suppressPackageStartupMessages(library(limma))

run_voom_main_effect <- function(pb_counts, pb_meta, trt) {
  stopifnot(trt %in% c("IL9","IL18"))
  meta <- pb_meta
  keep <- meta$condition %in% c("wo", trt)
  meta <- meta[keep, , drop = FALSE]
  if (nrow(meta) < 3) return(NULL)

  dge <- edgeR::DGEList(counts = pb_counts[, keep, drop = FALSE])
  keep_genes <- rowSums(edgeR::cpm(dge) > pseudo_min_cpm) >= pseudo_min_smp
  if (sum(keep_genes) < 100) return(NULL)
  dge <- dge[keep_genes, , keep.lib.sizes = FALSE]
  dge <- edgeR::calcNormFactors(dge, method = "TMM")

  meta$condition <- factor(meta$condition, levels = c("wo", trt))
  design <- model.matrix(~ 0 + condition, data = meta)
  colnames(design) <- levels(meta$condition)

  v <- limma::voom(dge, design = design, plot = FALSE)
  fit <- limma::lmFit(v, design)
  contr <- limma::makeContrasts(contrasts = paste0(trt, "-wo"), levels = design)
  fit2 <- limma::contrasts.fit(fit, contr)
  fit2 <- limma::eBayes(fit2, robust = TRUE, trend = TRUE)
  tt <- limma::topTable(fit2, number = Inf, sort.by = "P")
  tt$gene <- rownames(tt)
  tt
}

for (r in names(pb_all_res)) {
  d <- make_res_dirs(project_dir, r)
  for (lab in names(pb_all_res[[r]])) {
    pb <- pb_all_res[[r]][[lab]]
    for (trt in c("IL9","IL18")) {
      tt <- run_voom_main_effect(pb$counts, pb$meta, trt)
      if (is.null(tt)) next
      out_csv <- file.path(d$de, sprintf("limma_voom_main_%s_vs_wo_celltype_%s.csv", trt, gsub("[^A-Za-z0-9]+","_", lab)))
      readr::write_csv(tt, out_csv)
    }
  }
}
```

## 18) Optional interaction test (healthy vs diseased difference-in-differences)

```{r}
if (!requireNamespace("edgeR", quietly = TRUE)) {
  if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
  BiocManager::install("edgeR", ask = FALSE, update = FALSE)
}
suppressPackageStartupMessages(library(edgeR))

run_edger_interaction <- function(pb_counts, pb_meta, trt, healthy_ids, diseased_ids) {
  stopifnot(trt %in% c("IL9","IL18"))
  meta <- pb_meta
  meta$group <- NA_character_
  meta$group[meta$donor %in% healthy_ids]  <- "healthy"
  meta$group[meta$donor %in% diseased_ids] <- "diseased"
  meta <- meta[!is.na(meta$group), , drop = FALSE]
  keep <- meta$condition %in% c("wo", trt)
  meta <- meta[keep, , drop = FALSE]
  if (nrow(meta) < 4) return(NULL)

  tab_gc <- table(meta$group, meta$condition)
  if (!all(c("healthy","diseased") %in% rownames(tab_gc))) return(NULL)
  if (tab_gc["healthy","wo"] < 1 || tab_gc["healthy",trt] < 1)  return(NULL)
  if (tab_gc["diseased","wo"] < 1 || tab_gc["diseased",trt] < 1) return(NULL)

  y <- DGEList(counts = pb_counts[, keep, drop = FALSE])
  keep_genes <- rowSums(cpm(y) > pseudo_min_cpm) >= pseudo_min_smp
  if (sum(keep_genes) < 100) return(NULL)
  y <- y[keep_genes, , keep.lib.sizes = FALSE]
  y <- calcNormFactors(y, method = "TMM")

  meta$group     <- factor(meta$group, levels = c("healthy","diseased"))
  meta$condition <- factor(meta$condition, levels = c("wo", trt))
  design <- model.matrix(~ group * condition, data = meta)

  y <- estimateDisp(y, design)
  fit <- glmQLFit(y, design, robust = TRUE)

  coef_name <- paste0("groupdiseased:condition", trt)
  if (!coef_name %in% colnames(design)) return(NULL)
  coef_idx <- which(colnames(design) == coef_name)

  qlf <- glmQLFTest(fit, coef = coef_idx)
  tt  <- edgeR::topTags(qlf, n = Inf)$table
  tt$gene <- rownames(tt)
  tt
}

for (r in names(pb_all_res)) {
  d <- make_res_dirs(project_dir, r)
  for (lab in names(pb_all_res[[r]])) {
    pb <- pb_all_res[[r]][[lab]]
    for (trt in c("IL9","IL18")) {
      tt <- run_edger_interaction(pb$counts, pb$meta, trt, healthy_donors, diseased_donors)
      if (is.null(tt)) next
      out_csv <- file.path(d$de, sprintf("edgeR_interaction_%s_vs_wo_celltype_%s.csv", trt, gsub("[^A-Za-z0-9]+","_", lab)))
      readr::write_csv(tt, out_csv)
    }
  }
}
```

## 19) Session info

```{r}
sessionInfo()
```
